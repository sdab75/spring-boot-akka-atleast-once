package com.ms.common;

import akka.actor.ActorPath;
import akka.actor.ActorRef;
import akka.actor.ActorSelection;
import akka.event.Logging;
import akka.event.LoggingAdapter;
import akka.japi.Function;
import akka.japi.Procedure;
import akka.persistence.UntypedPersistentActorWithAtLeastOnceDelivery;
import com.ms.event.EDFEvent;
import com.ms.event.EDFEventDeliveryAck;
import org.springframework.stereotype.Component;

@Component
public abstract class AtleastOnceEventSender extends UntypedPersistentActorWithAtLeastOnceDelivery {
    private LoggingAdapter LOG = Logging.getLogger(getContext().system(), this);

    ActorRef path=null;

    public AtleastOnceEventSender(){
        path=destinationActorPath();
    }
   // private ActorSelection destination;

    @Override
    public void preStart() throws Exception {
    //    destination = getContext().actorSelection(path.path());
    }

    @Override
    public void onReceiveCommand(Object message) {

        /* Step1: The event sender receives a regular message.
         Using the message create MsgSent object and store that in the db.*/
        if (message instanceof EDFEvent) {
            EDFEvent edfEvent = (EDFEvent) message;
            /* Step2: The following persist command saves the MsgSent object
            and further hands over that object to updateState operation.*/
            persist(edfEvent, new Procedure<EDFEvent>() {
                public void apply(EDFEvent evt) {
                    updateState(evt);
                }
            });
        } else if (message instanceof EDFEventDeliveryAck) {
            log("Received confirmation ===>" + message.toString());
            /*Step4: The destination (MyDestination) sends a Confirm object to the sender (EventSender). */
            EDFEventDeliveryAck confirm = (EDFEventDeliveryAck) message;
            persist(confirm, new Procedure<EDFEventDeliveryAck>() {
                public void apply(EDFEventDeliveryAck evt) {
                    updateState(evt);
                }
            });
        } else {
            log("Received unhandled object ===>" + message.toString());
            unhandled(message);
        }
    }

    @Override
    public void onReceiveRecover(Object event) {
        log("Recovered object info ===>" + event.toString());

        updateState(event);
    }

    void updateState(Object event) {
        if (event instanceof EDFEvent) {
            log("Sending message to ===>" +destinationActorPath()+", with event data ===> "+ event.toString());
            /*Step3: Using MsgSent this operation creates the destination object (Msg)
            and asynchronously delivers Msg to the destination.
             The confirmation will be sent by the destination and this operation is not waiting for the confirmation.*/
            final EDFEvent evt = (EDFEvent) event;
            deliver(getContext().actorSelection(path.path()), new Function<Long, Object>() {
                public Object apply(Long deliveryId) {
                    //set Delivery Id sequence generated by Akka which will be used for later ack deliveryId.
                    evt.setEventDeliveryId(deliveryId);
                    return evt;
                }
            });
        } else if (event instanceof EDFEventDeliveryAck) {
            final EDFEventDeliveryAck ack = (EDFEventDeliveryAck) event;
            log("Received confirmation from "+getSender() +"with delivery Id==>" + ack.getEventDeliveryId());
            confirmDelivery(ack.getEventDeliveryId());
        }
    }

    protected void log(String msg){
        LOG.info(actorName() + " : " + msg);
    }

    protected abstract ActorRef destinationActorPath();

    protected abstract String actorName();

}
